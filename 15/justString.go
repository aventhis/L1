// just_string.go
// ---------------------
// Демонстрация проблемы среза строки и утечки памяти,
// а также правильного способа получения подстроки без утечки памяти

package main

//Если сделать justString = v[:100], где v — большая строка,
//то переменная justString будет ссылаться на те же данные в памяти,
//что и v. В результате, даже если нам нужна только часть строки,
//в памяти всё равно останется весь исходный (возможно, очень большой) буфер.
//	Это может привести к утечке памяти.

var justString string // глобальная переменная для хранения подстроки

func someFunc() {
	v := createHugeString(1 << 10) // createHugeString(1024)
	// justString = v[:100]
	// ВАЖНО! Так делать нельзя, иначе justString будет "держать" в памяти весь буфер v.

	// Правильно: создаём новую строку (копию первых 100 символов),
	// чтобы исходная большая строка v могла быть удалена сборщиком мусора.
	justString = string([]byte(v[:100]))

}

func main() {
	someFunc()
}

// Вариант с justString = v[:100]:
// justString будет содержать первые 100 символов, но весь большой буфер v не освободится из памяти.

// Вариант с justString = string([]byte(v[:100])):
// justString — это уже независимая копия, и память под v может быть освобождена сборщиком мусора.

// Поэтому второй способ — правильный, чтобы не было утечки памяти.
